#pragma once

#include <string>

// If available, pull in the generated version macros.
//
// This makes <qeeg/version.hpp> work for non-CMake consumers (e.g. pkg-config),
// where INTERFACE_COMPILE_DEFINITIONS from a CMake target would not apply.
#if defined(__has_include)
  #if __has_include(<qeeg/version_config.hpp>)
    #include <qeeg/version_config.hpp>
  #endif
#endif

namespace qeeg {

// Project version string as defined by CMake's project(VERSION ...).
//
// This header is intentionally dependency-free and safe to include from both the
// library and CLI tools.
//
// Normally these macros are provided by the build system (CMake), but when
// consuming via other systems (e.g. pkg-config) they come from the generated
// <qeeg/version_config.hpp> header installed alongside this file.
#ifndef QEEG_VERSION_STRING
  #define QEEG_VERSION_STRING "0.0.0"
#endif

// Numeric version components.
//
// These are generated by CMake in <qeeg/version_config.hpp> and are useful for
// programmatic version checks.
#ifndef QEEG_VERSION_MAJOR
  #define QEEG_VERSION_MAJOR 0
#endif

#ifndef QEEG_VERSION_MINOR
  #define QEEG_VERSION_MINOR 0
#endif

#ifndef QEEG_VERSION_PATCH
  #define QEEG_VERSION_PATCH 0
#endif

// Optional: best-effort git describe string (set by CMake when building from a git checkout).
//
// This is intentionally a simple string macro to keep the header dependency-free.
#ifndef QEEG_GIT_DESCRIBE
  #define QEEG_GIT_DESCRIBE "unknown"
#endif

inline const char* version_cstr() {
  return QEEG_VERSION_STRING;
}

inline int version_major() {
  return QEEG_VERSION_MAJOR;
}

inline int version_minor() {
  return QEEG_VERSION_MINOR;
}

inline int version_patch() {
  return QEEG_VERSION_PATCH;
}

inline bool version_at_least(int major, int minor, int patch) {
  if (version_major() != major) return version_major() > major;
  if (version_minor() != minor) return version_minor() > minor;
  return version_patch() >= patch;
}

inline const char* git_describe_cstr() {
  return QEEG_GIT_DESCRIBE;
}

inline std::string version_string() {
  return std::string(version_cstr());
}

inline std::string git_describe_string() {
  return std::string(git_describe_cstr());
}

inline std::string build_type_string() {
#ifdef NDEBUG
  return "Release";
#else
  return "Debug";
#endif
}

inline std::string compiler_string() {
#if defined(__clang__)
  return std::string("Clang ") + std::to_string(__clang_major__) + "." +
         std::to_string(__clang_minor__) + "." + std::to_string(__clang_patchlevel__);
#elif defined(__GNUC__)
  return std::string("GCC ") + std::to_string(__GNUC__) + "." +
         std::to_string(__GNUC_MINOR__) + "." + std::to_string(__GNUC_PATCHLEVEL__);
#elif defined(_MSC_VER)
  return std::string("MSVC ") + std::to_string(_MSC_VER);
#else
  return "unknown";
#endif
}

inline std::string cpp_standard_string() {
  const long long v = static_cast<long long>(__cplusplus);
  if (v >= 202302L) return "c++23";
  if (v >= 202002L) return "c++20";
  if (v >= 201703L) return "c++17";
  if (v >= 201402L) return "c++14";
  if (v >= 201103L) return "c++11";
  return "c++?";
}

} // namespace qeeg
